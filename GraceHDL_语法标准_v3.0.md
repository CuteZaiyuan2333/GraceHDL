# GraceHDL è¯­æ³•æ ‡å‡† v3.0

åŸºäºå®é™…demoæ–‡ä»¶éªŒè¯çš„è¯­æ³•å’Œè§„åˆ’åŠŸèƒ½çš„å®Œæ•´è¯­æ³•æ ‡å‡†å®šä¹‰ã€‚

## âš¡ é‡è¦æç¤ºï¼šåŒé‡èµ‹å€¼è¯­æ³•ç³»ç»Ÿ

GraceHDL æä¾›ä¸¤ç§èµ‹å€¼è¯­æ³•ï¼Œå¯¹åº”ä¸åŒçš„ç¡¬ä»¶è¯­ä¹‰ï¼š

- **`to` è¯­æ³•**ï¼šéé˜»å¡èµ‹å€¼ â†’ `value to reg` è½¬æ¢ä¸º `reg <= value`ï¼ˆ**æ—¶åºé€»è¾‘æ¨è**ï¼‰
- **`=` è¯­æ³•**ï¼šé˜»å¡èµ‹å€¼ â†’ `reg = value` è½¬æ¢ä¸º `reg = value`ï¼ˆç»„åˆé€»è¾‘æˆ–ç‰¹æ®Šæƒ…å†µï¼‰

ğŸ’¡ **æœ€ä½³å®è·µ**ï¼šåœ¨ `run` å—ä¸­ä¼˜å…ˆä½¿ç”¨ `to` è¯­æ³•ï¼Œç¡®ä¿æ—¶åºå®‰å…¨ï¼

## ğŸ“‹ ç›®å½•
1. [åŸºæœ¬è¯­æ³•ç»“æ„](#1-åŸºæœ¬è¯­æ³•ç»“æ„)
2. [æ•°æ®ç±»å‹å’Œä½å®½è¡¨ç¤º](#2-æ•°æ®ç±»å‹å’Œä½å®½è¡¨ç¤º)
3. [é€»è¾‘å—è¯­æ³•](#3-é€»è¾‘å—è¯­æ³•)
4. [èµ‹å€¼è¯­æ³•](#4-èµ‹å€¼è¯­æ³•) â­
5. [æ“ä½œç¬¦å’Œè¡¨è¾¾å¼](#5-æ“ä½œç¬¦å’Œè¡¨è¾¾å¼)
6. [æ§åˆ¶ç»“æ„](#6-æ§åˆ¶ç»“æ„)
7. [é«˜çº§è¯­æ³•ç‰¹æ€§](#7-é«˜çº§è¯­æ³•ç‰¹æ€§)
8. [æ¨¡å—å®ä¾‹åŒ–](#8-æ¨¡å—å®ä¾‹åŒ–)
9. [è¯­æ³•é£æ ¼è§„èŒƒ](#9-è¯­æ³•é£æ ¼è§„èŒƒ)

---

## 1. åŸºæœ¬è¯­æ³•ç»“æ„

### 1.1 æ¨¡å—å®šä¹‰
```ghdl
module module_name:
    # æ¨¡å—å†…å®¹ä½¿ç”¨4ç©ºæ ¼ç¼©è¿›
    input(
        # è¾“å…¥ç«¯å£å®šä¹‰
    )
    output(
        # è¾“å‡ºç«¯å£å®šä¹‰
    )
    register(
        # å¯„å­˜å™¨å®šä¹‰ï¼ˆå¯é€‰ï¼‰
    )
    parameter(
        # å‚æ•°å®šä¹‰ï¼ˆå¯é€‰ï¼‰
    )
    
    # é€»è¾‘å—
```

### 1.2 ç«¯å£å®šä¹‰è¯­æ³•
```ghdl
# å•æ¯”ç‰¹ä¿¡å·
wire signal_name

# å¤šæ¯”ç‰¹ä¿¡å· - ä½¿ç”¨é€—å·åˆ†éš”çš„ä½å®½è¡¨ç¤º
wire(high_bit, low_bit) signal_name

# ç¤ºä¾‹
input(
    wire clk,
    wire rst,
    wire(7, 0) data_in,
    wire(15, 0) address
)

output(
    wire ready,
    wire(7, 0) data_out
)
```

### 1.3 å¯„å­˜å™¨å®šä¹‰è¯­æ³•
```ghdl
register(
    reg signal_name,                    # å•æ¯”ç‰¹å¯„å­˜å™¨
    reg(high_bit, low_bit) signal_name, # å¤šæ¯”ç‰¹å¯„å­˜å™¨
    reg(width-1, 0) memory[size-1, 0]   # å­˜å‚¨å™¨æ•°ç»„ï¼ˆè§„åˆ’ä¸­ï¼‰
)

# ç¤ºä¾‹
register(
    reg(7, 0) counter,
    reg(1, 0) state,
    reg q_reg
)
```

### 1.4 å‚æ•°å®šä¹‰è¯­æ³•ï¼ˆè§„åˆ’ä¸­ï¼‰
```ghdl
parameter(
    PARAM_NAME = value,
    WIDTH = 8,
    DEPTH = 256
)
```

---

## 2. æ•°æ®ç±»å‹å’Œä½å®½è¡¨ç¤º

### 2.1 æ•°æ®ç±»å‹
- `wire`: è¿çº¿ç±»å‹ï¼Œç”¨äºç»„åˆé€»è¾‘
- `reg`: å¯„å­˜å™¨ç±»å‹ï¼Œç”¨äºæ—¶åºé€»è¾‘

### 2.2 ä½å®½è¡¨ç¤º
```ghdl
wire(7, 0) data      # 8ä½å®½åº¦ [7:0]
wire(15, 0) address  # 16ä½å®½åº¦ [15:0]
reg(31, 0) register  # 32ä½å¯„å­˜å™¨
```

### 2.3 æ•°å€¼è¡¨ç¤º
```ghdl
# æ–°æ•°å€¼æ ¼å¼ (value, base, width)
(0, d, 8)       # 8ä½åè¿›åˆ¶0
(255, d, 8)     # 8ä½åè¿›åˆ¶255
(0xFF, h, 8)    # 8ä½åå…­è¿›åˆ¶FF
(0b10101010, b, 8)  # 8ä½äºŒè¿›åˆ¶

# ç®€åŒ–è¡¨ç¤º
0               # é›¶å€¼ï¼ˆç¼–è¯‘å™¨è‡ªåŠ¨æ¨æ–­ä½å®½ï¼‰
1               # ä¸€å€¼ï¼ˆç¼–è¯‘å™¨è‡ªåŠ¨æ¨æ–­ä½å®½ï¼‰
```

### 2.4 ä½é€‰æ‹©å’Œæ‹¼æ¥
```ghdl
# ä½é€‰æ‹©
signal[7]           # é€‰æ‹©ç¬¬7ä½
signal[7, 0]        # é€‰æ‹©ä½æ®µ[7:0]
signal[6, 0]        # é€‰æ‹©ä½æ®µ[6:0]

# ä½æ‹¼æ¥
result = a + b      # æ‹¼æ¥æ“ä½œ
shift_reg = shift_reg[6, 0] + serial_in  # ç§»ä½æ‹¼æ¥
```

---

## 3. é€»è¾‘å—è¯­æ³•

### 3.1 æ—¶é’Ÿé©±åŠ¨é€»è¾‘ (run å—)
```ghdl
# ä¸Šå‡æ²¿è§¦å‘
run(clk.posedge):
    # æ—¶åºé€»è¾‘ï¼Œæ¨èä½¿ç”¨ to è¯­æ³•ï¼ˆéé˜»å¡èµ‹å€¼ï¼‰
    if rst:
        0 to counter              # éé˜»å¡èµ‹å€¼ â† æ¨è
        0 to state               # éé˜»å¡èµ‹å€¼ â† æ¨è
    else:
        (counter + 1) to counter  # éé˜»å¡èµ‹å€¼ â† æ¨è
        next_state to state      # éé˜»å¡èµ‹å€¼ â† æ¨è
    
    # ä¹Ÿæ”¯æŒä¼ ç»Ÿ = è¯­æ³•ï¼ˆé˜»å¡èµ‹å€¼ï¼‰ï¼Œä½†éœ€è°¨æ…ä½¿ç”¨
    # counter = counter + 1     # é˜»å¡èµ‹å€¼ï¼Œå¯èƒ½å¯¼è‡´æ—¶åºé—®é¢˜

# ä¸‹é™æ²¿è§¦å‘
run(clk.negedge):
    # åŒæ­¥é€»è¾‘ï¼ŒåŒæ ·æ¨èä½¿ç”¨ to è¯­æ³•
    data_in to shift_reg

# å¤šæ¡ä»¶è§¦å‘ï¼ˆè§„åˆ’ä¸­ï¼‰
run(clk.posedge and rst.negedge):
    # å¸¦å¼‚æ­¥å¤ä½çš„åŒæ­¥é€»è¾‘
```

### 3.2 ç»„åˆé€»è¾‘ (always å—)
```ghdl
always:
    # ç»„åˆé€»è¾‘ï¼Œä½¿ç”¨ = èµ‹å€¼
    case addr:
        (0, d, 3):
            out = (1, d, 8)
        (1, d, 3):
            out = (2, d, 8)
        default:
            out = (0, d, 8)
```

### 3.3 è¿ç»­èµ‹å€¼ (assign å—)
```ghdl
assign:
    # è¿ç»­èµ‹å€¼è¯­å¥
    y = a and b
    sum = a xor b xor cin
    cout = (a and b) or (cin and (a xor b))
```

---

## 4. èµ‹å€¼è¯­æ³•

### 4.1 é˜»å¡èµ‹å€¼è¯­æ³•ï¼ˆ= æ“ä½œç¬¦ï¼‰
```ghdl
# åœ¨ run å—ä¸­ä½¿ç”¨ = è¿›è¡Œé˜»å¡èµ‹å€¼ï¼ˆè½¬æ¢ä¸º Verilog çš„ = ï¼‰
run(clk.posedge):
    counter = counter + 1         # é˜»å¡èµ‹å€¼
    data_reg = data_in           # é˜»å¡èµ‹å€¼

# åœ¨ always å’Œ assign å—ä¸­ä½¿ç”¨ = è¿›è¡Œç»„åˆèµ‹å€¼
always:
    output = input_a and input_b  # ç»„åˆé€»è¾‘èµ‹å€¼

assign:
    sum = a + b                  # è¿ç»­èµ‹å€¼
```

### 4.2 éé˜»å¡èµ‹å€¼è¯­æ³•ï¼ˆto æ“ä½œç¬¦ï¼‰â­
```ghdl
# ä½¿ç”¨ to è¯­æ³•è¿›è¡Œéé˜»å¡èµ‹å€¼ï¼Œä¸“ç”¨äºæ—¶åºé€»è¾‘
run(clk.posedge):
    (counter + 1) to counter      # éé˜»å¡èµ‹å€¼ï¼Œè½¬æ¢ä¸º Verilog çš„ counter <= counter + 1
    data_in to data_reg           # éé˜»å¡èµ‹å€¼ï¼Œè½¬æ¢ä¸º Verilog çš„ data_reg <= data_in
    0 to reset_counter            # éé˜»å¡èµ‹å€¼ï¼Œè½¬æ¢ä¸º Verilog çš„ reset_counter <= 0

# âš ï¸ é‡è¦ï¼što è¯­æ³•åªèƒ½åœ¨ run å—ä¸­ä½¿ç”¨ï¼Œä¸èƒ½åœ¨ always æˆ– assign å—ä¸­ä½¿ç”¨
```

### 4.3 èµ‹å€¼è¯­æ³•ç‰¹æ€§å¯¹æ¯”
| èµ‹å€¼ç±»å‹ | GraceHDL è¯­æ³• | Verilog è½¬æ¢ | æ‰§è¡Œç‰¹æ€§ | æ¨èä½¿ç”¨åœºæ™¯ |
|----------|---------------|-------------|----------|-------------|
| **éé˜»å¡èµ‹å€¼** | `value to reg` | `reg <= value` | å¹¶è¡Œæ‰§è¡Œï¼Œæ—¶åºå®‰å…¨ | **æ—¶åºé€»è¾‘ï¼ˆæ¨èï¼‰** |
| é˜»å¡èµ‹å€¼ | `reg = value` | `reg = value` | é¡ºåºæ‰§è¡Œ | ç»„åˆé€»è¾‘æˆ–ç‰¹æ®Šæƒ…å†µ |
| ç»„åˆèµ‹å€¼ | `wire = value` | `assign wire = value` | è¿ç»­èµ‹å€¼ | always/assign å— |

### 4.4 èµ‹å€¼è¯­æ³•é€‰æ‹©æŒ‡å—
```ghdl
# âœ… æ¨èï¼šæ—¶åºé€»è¾‘ä½¿ç”¨ to è¯­æ³•ï¼ˆéé˜»å¡ï¼‰
run(clk.posedge):
    if rst:
        0 to counter              # éé˜»å¡èµ‹å€¼
        0 to state               # éé˜»å¡èµ‹å€¼
    else:
        (counter + 1) to counter  # éé˜»å¡èµ‹å€¼
        next_state to state      # éé˜»å¡èµ‹å€¼

# âš ï¸ è°¨æ…ä½¿ç”¨ï¼šæ—¶åºé€»è¾‘ä¸­çš„é˜»å¡èµ‹å€¼
run(clk.posedge):
    temp = data_in               # é˜»å¡èµ‹å€¼ï¼Œå¯èƒ½å¯¼è‡´æ—¶åºé—®é¢˜
    temp to output_reg           # éé˜»å¡èµ‹å€¼

# âœ… æ­£ç¡®ï¼šç»„åˆé€»è¾‘ä½¿ç”¨ = è¯­æ³•
always:
    output = input_a and input_b # ç»„åˆé€»è¾‘èµ‹å€¼

assign:
    sum = a + b                  # è¿ç»­èµ‹å€¼
```

---

## 5. æ“ä½œç¬¦å’Œè¡¨è¾¾å¼

### 5.1 é€»è¾‘æ“ä½œç¬¦
```ghdl
and     # é€»è¾‘ä¸
or      # é€»è¾‘æˆ–
not     # é€»è¾‘é
xor     # é€»è¾‘å¼‚æˆ–
```

### 5.2 ç®—æœ¯æ“ä½œç¬¦
```ghdl
+       # åŠ æ³•
-       # å‡æ³•
*       # ä¹˜æ³•ï¼ˆè§„åˆ’ä¸­ï¼‰
/       # é™¤æ³•ï¼ˆè§„åˆ’ä¸­ï¼‰
```

### 5.3 æ¯”è¾ƒæ“ä½œç¬¦
```ghdl
==      # ç­‰äº
!=      # ä¸ç­‰äº
<       # å°äº
>       # å¤§äº
<=      # å°äºç­‰äº
>=      # å¤§äºç­‰äº
```

### 5.4 ä½æ“ä½œç¬¦
```ghdl
~       # æŒ‰ä½å–å
&       # æŒ‰ä½ä¸ï¼ˆè§„åˆ’ä¸­ï¼‰
|       # æŒ‰ä½æˆ–ï¼ˆè§„åˆ’ä¸­ï¼‰
^       # æŒ‰ä½å¼‚æˆ–ï¼ˆè§„åˆ’ä¸­ï¼‰
```

---

## 6. æ§åˆ¶ç»“æ„

### 6.1 æ¡ä»¶è¯­å¥
```ghdl
# if-elif-else è¯­å¥
if condition:
    # è¯­å¥
elif another_condition:
    # è¯­å¥
else:
    # è¯­å¥

# ç¤ºä¾‹
if rst:
    count_reg = 0
elif load:
    count_reg = load_value
elif enable:
    count_reg = count_reg + 1
```

### 6.2 case è¯­å¥
```ghdl
case variable:
    value1:
        # è¯­å¥
    value2:
        # è¯­å¥
    default:
        # é»˜è®¤è¯­å¥

# ç¤ºä¾‹
case addr:
    (0, d, 3):
        out = (1, d, 8)
    (1, d, 3):
        out = (2, d, 8)
    default:
        out = (0, d, 8)
```

---

## 7. é«˜çº§è¯­æ³•ç‰¹æ€§

### 7.1 Forå¾ªç¯ç”Ÿæˆè¯­å¥ï¼ˆè§„åˆ’ä¸­ï¼‰
```ghdl
# Forå¾ªç¯ç”Ÿæˆè¯­å¥ - ç”¨äºé‡å¤ç¡¬ä»¶ç»“æ„ç”Ÿæˆ
for i in range(start, end):
    # ç”Ÿæˆé‡å¤çš„ç¡¬ä»¶ç»“æ„
    
# ç¤ºä¾‹ï¼šç”Ÿæˆå¤šä¸ªå¯„å­˜å™¨
for i in range(0, 8):
    register(
        reg data_reg[i]
    )
```

### 7.2 æšä¸¾ç±»å‹ï¼ˆè§„åˆ’ä¸­ï¼‰
```ghdl
enum State:
    IDLE = 0,
    FETCH = 1,
    DECODE = 2,
    EXECUTE = 3

register(
    State current_state
)

run(clk.posedge):
    if reset:
        current_state = State.IDLE
    else:
        case current_state:
            State.IDLE: current_state = State.FETCH
            State.FETCH: current_state = State.DECODE
```

### 7.3 å‡½æ•°å®šä¹‰ï¼ˆè§„åˆ’ä¸­ï¼‰
```ghdl
function add(a: wire(7, 0), b: wire(7, 0)) -> wire(8, 0):
    return a + b

always:
    result = add(operand_a, operand_b)
```

### 7.4 æ¥å£å®šä¹‰ï¼ˆè§„åˆ’ä¸­ï¼‰
```ghdl
interface bus_interface:
    wire(7, 0) data
    wire valid
    wire ready

module processor:
    input(
        wire clk,
        wire rst
    )
    bus_interface.master cpu_bus
```

---

## 8. æ¨¡å—å®ä¾‹åŒ–

### 8.1 åŸºæœ¬å®ä¾‹åŒ–è¯­æ³•
```ghdl
module top_module:
    input(
        wire clk,
        wire rst,
        wire(7, 0) data_in
    )
    output(
        wire(7, 0) data_out
    )
    
    # å®ä¾‹åŒ–å­æ¨¡å—
    counter_8bit counter_inst:
        .clk(clk),
        .rst(rst),
        .enable(1),
        .count(data_out)
```

### 8.2 å‚æ•°åŒ–å®ä¾‹åŒ–ï¼ˆè§„åˆ’ä¸­ï¼‰
```ghdl
parameterized_counter #(
    .WIDTH(16),
    .MAX_COUNT(65535)
) counter_16bit_inst:
    .clk(clk),
    .rst(rst),
    .enable(enable),
    .count(count_16)
```

---

## 9. è¯­æ³•é£æ ¼è§„èŒƒ

### 9.1 ç¼©è¿›è§„èŒƒ
- ä½¿ç”¨4ä¸ªç©ºæ ¼è¿›è¡Œç¼©è¿›
- æ¨¡å—å†…çš„æ‰€æœ‰å—ï¼ˆinputã€outputã€registerç­‰ï¼‰ç›¸å¯¹äºmoduleå…³é”®å­—ç¼©è¿›4ä¸ªç©ºæ ¼
- å—å†…çš„è¯­å¥ç›¸å¯¹äºå—å…³é”®å­—å†ç¼©è¿›4ä¸ªç©ºæ ¼

### 9.2 å‘½åè§„èŒƒ
- æ¨¡å—åï¼šä½¿ç”¨å°å†™å­—æ¯å’Œä¸‹åˆ’çº¿ï¼Œå¦‚ `counter_8bit`
- ä¿¡å·åï¼šä½¿ç”¨å°å†™å­—æ¯å’Œä¸‹åˆ’çº¿ï¼Œå¦‚ `data_in`, `clk_out`
- å‚æ•°åï¼šä½¿ç”¨å¤§å†™å­—æ¯å’Œä¸‹åˆ’çº¿ï¼Œå¦‚ `WIDTH`, `MAX_COUNT`

### 9.3 æ³¨é‡Šè§„èŒƒ
```ghdl
# å•è¡Œæ³¨é‡Š
# å¤šè¡Œæ³¨é‡Šçš„ç¬¬ä¸€è¡Œ
# å¤šè¡Œæ³¨é‡Šçš„ç¬¬äºŒè¡Œ

module example:  # è¡Œå†…æ³¨é‡Š
    input(
        wire clk  # æ—¶é’Ÿä¿¡å·
    )
```

### 9.4 ä»£ç ç»„ç»‡
- æ¯ä¸ªæ¨¡å—å®šä¹‰ç‹¬ç«‹æˆå—
- ç›¸å…³çš„æ¨¡å—å¯ä»¥æ”¾åœ¨åŒä¸€ä¸ªæ–‡ä»¶ä¸­
- å¤æ‚çš„è®¾è®¡å»ºè®®åˆ†æ–‡ä»¶ç»„ç»‡

---

## 10. å®é™…åº”ç”¨ç¤ºä¾‹

### 10.1 åŸºæœ¬é—¨ç”µè·¯
```ghdl
module and_gate:
    input(
        wire a,
        wire b
    )
    output(
        wire y
    )
    
    assign:
        y = a and b
```

### 10.2 æ—¶åºé€»è¾‘ï¼ˆæ¨èä½¿ç”¨éé˜»å¡èµ‹å€¼ï¼‰
```ghdl
module d_flip_flop:
    input(
        wire clk,
        wire rst,
        wire d
    )
    output(
        wire q
    )
    
    register(
        reg q_reg
    )
    
    run(clk.posedge):
        if rst:
            0 to q_reg           # éé˜»å¡èµ‹å€¼ â† æ¨è
        else:
            d to q_reg           # éé˜»å¡èµ‹å€¼ â† æ¨è
    
    assign:
        q = q_reg               # ç»„åˆé€»è¾‘èµ‹å€¼
```

### 10.3 çŠ¶æ€æœºï¼ˆæ¨èä½¿ç”¨éé˜»å¡èµ‹å€¼ï¼‰
```ghdl
module traffic_light_controller:
    input(
        wire clk,
        wire rst
    )
    output(
        wire(1, 0) lights
    )
    
    register(
        reg(1, 0) current_state,
        reg(3, 0) counter
    )
    
    run(clk.posedge):
        if rst:
            (0, d, 2) to current_state    # éé˜»å¡èµ‹å€¼ â† æ¨è
            (0, d, 4) to counter          # éé˜»å¡èµ‹å€¼ â† æ¨è
        else:
            if counter == (15, d, 4):
                (0, d, 4) to counter      # éé˜»å¡èµ‹å€¼ â† æ¨è
                case current_state:
                    (0, d, 2): (1, d, 2) to current_state    # éé˜»å¡èµ‹å€¼
                    (1, d, 2): (2, d, 2) to current_state    # éé˜»å¡èµ‹å€¼
                    (2, d, 2): (0, d, 2) to current_state    # éé˜»å¡èµ‹å€¼
                    default: (0, d, 2) to current_state      # éé˜»å¡èµ‹å€¼
            else:
                (counter + 1) to counter  # éé˜»å¡èµ‹å€¼ â† æ¨è
    
    assign:
        lights = current_state           # ç»„åˆé€»è¾‘èµ‹å€¼
```

---

## 11. ç¼–è¯‘å™¨æ”¯æŒçŠ¶æ€

### âœ… å·²å®ç°åŠŸèƒ½
- åŸºæœ¬æ¨¡å—å®šä¹‰å’Œç«¯å£å£°æ˜
- æ—¶åºé€»è¾‘ï¼ˆrunå—ï¼‰å’Œç»„åˆé€»è¾‘ï¼ˆalwayså—ï¼‰
- è¿ç»­èµ‹å€¼ï¼ˆassignå—ï¼‰
- æ¡ä»¶è¯­å¥ï¼ˆif-elif-elseï¼‰å’Œcaseè¯­å¥
- åŸºæœ¬æ•°æ®ç±»å‹ï¼ˆwireã€regï¼‰å’Œä½å®½æ”¯æŒ
- æ–°æ•°å€¼æ ¼å¼ (value, base, width)
- ä½é€‰æ‹©å’Œæ‹¼æ¥æ“ä½œ
- åŸºæœ¬æ“ä½œç¬¦æ”¯æŒ
- **åŒé‡èµ‹å€¼è¯­æ³•ç³»ç»Ÿ**ï¼š
  - `to` è¯­æ³•ï¼šéé˜»å¡èµ‹å€¼ï¼ˆ`value to reg` â†’ `reg <= value`ï¼‰
  - `=` è¯­æ³•ï¼šé˜»å¡èµ‹å€¼ï¼ˆ`reg = value` â†’ `reg = value`ï¼‰

### ğŸš§ è§„åˆ’ä¸­åŠŸèƒ½
- å‚æ•°åŒ–æ¨¡å—ç³»ç»Ÿ
- Forå¾ªç¯ç”Ÿæˆè¯­å¥
- æšä¸¾ç±»å‹ç³»ç»Ÿ
- å‡½æ•°å®šä¹‰ç³»ç»Ÿ
- æ¥å£å®šä¹‰ç³»ç»Ÿ
- é«˜çº§æ•°ç»„æ“ä½œ
- æ›´å¤šæ“ä½œç¬¦æ”¯æŒ

---

## 12. ç‰ˆæœ¬å†å²

### v3.0 (å½“å‰ç‰ˆæœ¬)
- åŸºäºå®é™…demoæ–‡ä»¶éªŒè¯çš„è¯­æ³•æ ‡å‡†
- æ˜ç¡®åŒºåˆ†å·²å®ç°å’Œè§„åˆ’ä¸­çš„åŠŸèƒ½
- ç»Ÿä¸€çš„è¯­æ³•é£æ ¼è§„èŒƒ
- å®Œæ•´çš„åº”ç”¨ç¤ºä¾‹

### v2.x (å·²å½’æ¡£)
- æ—©æœŸè¯­æ³•è§„èŒƒç‰ˆæœ¬
- éƒ¨åˆ†åŠŸèƒ½è§„åˆ’ä½†æœªéªŒè¯
- å·²ç§»åŠ¨åˆ° legacy_docs æ–‡ä»¶å¤¹

---

*æœ¬æ–‡æ¡£åŸºäºGraceHDLé¡¹ç›®çš„äº”ä¸ªdemoæ–‡ä»¶å®é™…è¯­æ³•å’Œå…¶ä»–è§„åˆ’æ–‡æ¡£ç¼–å†™ï¼Œç¡®ä¿è¯­æ³•æ ‡å‡†çš„å‡†ç¡®æ€§å’Œå®ç”¨æ€§ã€‚*